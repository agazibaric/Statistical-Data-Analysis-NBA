class(podaci3)
podaci3 = factor(podaci, labels = c("KNEZ","KRALJ","CAR"), ordered = T)
podaci3
# ucitavanje built-in dataseta
help(iris)
pod = iris
pod
# pregled samo prvih nekoliko redaka
head(pod)
# dimenzije dataseta
dim(pod)  # sirina i visina
nrow(pod) # broj redaka
ncol(pod) # broj stupaca
names(pod) # imena stupaca
# uvodna analiza, pristup stupcima data.frame objekta preko imena pomocu operatora $
pod$Sepal.Length
pod$Petal.Width
class(pod$Petal.Width)
# klasa ove varijable je "numeric" -- varijabla na intervalnoj/racionalnoj skali
pod$Species
class(pod$Species)
# klasa ove varijable je "factor" -- varijabla na nominalnoj/ordinalnoj skali
# osnovna deskriptivna statistika
summary(pod)
# konverzija data.frame-a i matrica
pod.mat = as.matrix(head(pod))
pod.mat
pod.df.from.mat = data.frame(pod.mat)
pod.df.from.mat
pod = head(iris)
# dodavanje stupca
pod$novi.stupac = c(3,2,1,3,2,1)
pod
class(pod$novi.stupac)
# micanje stupca
pod
pod$novi.stupac = NULL
pod
# dodavanje retka
novi.red = data.frame(5.1,3.2,1.6,0.5,"virginica")
class(novi.red)
novi.red
#pod = rbind(pod,novi.red) # ne radi jer imena stupaca ne odgovaraju
# ovo ispravlja problem
names(novi.red) = names(pod)
novi.red
pod = rbind(pod,novi.red)
pod
# micanje redova
pod = pod[-c(7),]
# znacenje negativnih indeksa je detaljno objasnjeno u iducem isjecku koda
pod
# indeksiranje
# jedan indeks izdvaja stupac
pod[2]
# ili vise stupaca (indeks je u ovom slucaju vektor brojeva)
pod[c(2,4)]
# ili sve osim odredjenih stupaca (negativni brojevi kao indeksi znace izostavljanje tih indeksa)
pod[-c(2,4)]
# kod vise (vektora) indeksa prvi predstavlja redak a drugi stupac
pod[c(2,5,6), c(3,4)]
# moze se promjeniti vrijednost na nekoj poziciji
pod[1,4] = 12
pod
# mogu se koristiti rangevi
pod[2:5, 1:3]
# 2:5 je isto kao da piše c(2,3,4,5)
# ili indeksi mogu biti izostavljeni
# retci 3 i 4 i svi stupci
pod[c(3,4),]
# svi retci i stupci 3 i 4
pod[,c(3,4)]
# stupci mogu biti zadani vektorom imena umjesto brojeva
pod[c(2,5,6), c("Sepal.Width","Species")]
# operator '-' radi kako bi ocekivali (uz uvjet da koristimo vektore brojeva)
pod[c(2,5,6), -c(5)]
# ovo je jedna varijanta koja ne radi jer operator '-' nije definiran za vektor character vrijednosti
# pod[c(2,5,6), -c("Species")]
# ali ovo se moze rijesiti logickim indeksiranjem sto cemo detaljnije obraditi u iducem isjecku koda
# uvjetno indeksiranje pomocu logical vektora
lv = pod$Sepal.Width > 3.3
lv
# svi redovi gdje je gornji uvjet zadovoljen
pod[lv,]
pod
# mozemo uvjete kombinirati
lv = pod$Sepal.Width > 3.3 & pod$Sepal.Length < 5.2
lv
# svi redovi gdje su oba gornja uvjeta zadovoljena
pod[lv,]
pod
# radi i za stupce
# imena stupaca
names(pod)
# logicki vektor koji ima true za sve stupce osim petog (koji je "Species")
names(pod) != "Species"
# logicko indeksiranje makne stupac species
pod[c(2,5,6), names(pod) != "Species"]
# Ovo rjesenje za micanje stupca po imenu radi ako zelimo maknuti samo jedan stupac.
# Sto bi bilo ako bismo htjeli maknuti dva ili vise stupaca, npr. "Petal.Length"
# i "Petal.Width"? Za to bismo imali slican kod kao gore ali bismo umjesto != koristili
# operator %in%. To mozete isprobati za vjezbu.
# osim na cijeli data frame mozemo primijeniti logicko indeksiranje i na bilo koji vektor, npr. pod$Sepal.Width
pod$Sepal.Width[pod$Sepal.Width > 3.5]
# vektor vrijedosti u Sepal.Width filtriran tako da ostanu samo one koje zadovoljavaju uvjet
# u uvjetu možemo koristiti neki drugi vektor npr.
pod$Sepal.Width[pod$Petal.Length > 1.4]
# vektor vrijednosti u Sepal.Width filtriran tako da ostanu samo one gdje pripadni Petal.Length zadovoljava uvjet
# uvjetno indeksiranje pomocu vektora indeksa
pod$Sepal.Width > 3.3
ind = which(pod$Sepal.Width > 3.3)
# vraca skup indeksa gdje je uvjet zadovoljen
ind
# standardno indeksiranje pomocu vektora brojeva (koje smo dohvatili naredbom which)
pod[ind,]
pod
# naredba which je korisna ako zelimo saznati npr. na kojem indeksu u data frame-u ili u vektoru se nalazi neki element
min.width = min(pod$Sepal.Width)
# ne znamo gdje je minimum
which(pod$Sepal.Width == min.width)
# ovo nam dohvaca tocan indeks
install.packages("tidyverse")
library(tidyverse)
library(dplyr)
p = iris
p
#p %>% group_py(Species) -> result
iris %>% group_by(Vrsta = Species) %>% summarize(ProsjekSL = mean(Sepal.Length)) -> result
result
# dodatno, vrlo koristan skup biblioteka, koji omogućuje još elegantniju manipulaciju data frame-ovima je tidyverse
# npr. recimo da smo htjeli dobiti medijane i prosjeke sepal.width ali grupirano po pojedinoj vrsti irisa
library(tidyverse)
iris %>% group_by(Vrsta = Species) %>% summarize(ProsjekSL = mean(Sepal.Length), MedijanSL = median(Sepal.Length)) -> rez
rez
# ucitavanje podataka iz csv datoteke
setwd("/Users/Antun/Documents/fer/sap/lab1")
pod = read.table("iris_missing_values.txt")
head(pod)
# vidimo da se sve krivo ucitalo jer nije dobar separator pa cemo popraviti separator
pod = read.table("iris_missing_values.txt", sep = ",")
head(pod)
# i sada je sve u redu
# pretvaranje tipova stupaca ako se krivo ucitaju
class(pod$Species)
# klasa je numeric, a to nije dobro jer je to klasa cvijeca -- nominalna varijabla
pod$Species = as.factor(pod$Species)
# "as.factor"" je samo wrapper oko funkcije "factor" koju smo vec koristili
class(pod$Species)
# sada je "factor" kako i treba biti
pod$Species
# ako zelimo pretvoriti natrag u broj
pod$Species = as.numeric(pod$Species)
# VAZNO: as.numeric primjenjen na faktor varijable ce vratiti vektor indeksa levela faktor varijable, cak i kada je same diskretne
# vrijednosti faktor varijable moguce pretvoriti u brojeve npr.
fvar = factor(c(10000,21000,42000, 21000,42000,10000))
as.numeric(fvar) # vraca 1 2 3 2 3 1, a ne 10000,21000,42000, 21000,42000,10000
# jedan nacin za dobiti brojke direktno iz vrijednosti faktor varijable je da se ona prvo pretvori u character pa onda u numeric
as.numeric(as.character(fvar)) # vraca 10000,21000,42000, 21000,42000,10000
# nedostajuce vrijednosti
# is.na ce nam vratiti logical vektor koji ima TRUE na mjestima gdje pod$Petal.Length ima NA
# sum funkcija na logical vektorima broji TRUE kao 1 a FALSE kao 0, pa zapravo prebroji koliko elemenata vektora je TRUE
sum(is.na(pod$Petal.Length)) # 1
sum(is.na(pod$Sepal.Length)) # 4
sum(is.na(pod$Species)) # 0
# complete.cases ce vratiti logical vrijednost za svaki redak. Vrijednost je FALSE akko je *barem jedan* element retka NA
sum(!complete.cases(pod))
# tako je i najlakse izbaciti nedostajuce vrijednosti
pod2 = pod[complete.cases(pod),]
irisdata = iris
# aritmeticka sredina
mean(irisdata$Petal.Length)
# podrezana aritmeticka sredina s uklanjanjem po 20% najmanjih i najvecih podataka
mean(irisdata$Petal.Length, trim=0.2)
# medijan
median(irisdata$Petal.Length)
# 1., 2. i 3. kvartil
quantile(irisdata$Petal.Length, probs = c(0.25,0.5,0.75))
# require(modeest)
# ako ne radi modeest, istu funkciju sadrzi i paket 'statip'
# mod
# mfv(irisdata$Petal.Length)
# rang
max(irisdata$Petal.Length)-min(irisdata$Petal.Length)
# interkvartilni rang
IQR(irisdata$Petal.Length)
# varijanca
var(irisdata$Petal.Length)
# standardna devijacija
sd(irisdata$Petal.Length)
sqrt(var(irisdata$Petal.Length))
# ukljucivanje paketa raster, s iskljucenim ispisivanjem poruka (kako se u izvjescu ne bi pojavljivala upozorenja i poruke o paketu)
# suppressWarnings(require(raster,quietly = TRUE))
# koeficijent varijacije
# cv(irisdata$Petal.Length)
mean(irisdata$Petal.Length[irisdata$Species=='setosa'])
mean(irisdata$Petal.Length[irisdata$Species=='versicolor'])
mean(irisdata$Petal.Length[irisdata$Species=='virginica'])
median(irisdata$Petal.Length[irisdata$Species=='setosa'])
median(irisdata$Petal.Length[irisdata$Species=='versicolor'])
median(irisdata$Petal.Length[irisdata$Species=='virginica'])
mean(irisdata$Petal.Length[irisdata$Species=='setosa'],trim=0.15)
mean(irisdata$Petal.Length[irisdata$Species=='versicolor'],trim=0.15)
mean(irisdata$Petal.Length[irisdata$Species=='virginica'],trim=0.15)
# isto, samo malo elegantnije
aggregate(irisdata[, 3], list(irisdata$Species), mean)
aggregate(irisdata[, 3], list(irisdata$Species), median)
aggregate(irisdata[, 3], list(irisdata$Species), mean,trim=0.15)
# histogram duljine lapa s cca. 20-30 razreda (broj razreda shvaca kao "sugestiju")
hist(irisdata$Sepal.Length,breaks=25,main='Sepal length histogram',
xlab='Sepal length [cm]',ylab='Frequency')
# histogram s prikazom relativnih frekvencija
h = hist(irisdata$Sepal.Length,prob=TRUE,breaks=15,main='Sepal length histogram',
xlab='Sepal length [cm]',ylab='Relative frequency')
# pravokutni dijagram duljine lapa, s postavljenim naslovom i oznakom na y osi
boxplot(irisdata$Sepal.Length,main='Sepal length box-plot',ylab='Sepal length [cm]')
# vrijednosti pravokutnog dijagrama dolaze iz deskriptivne statistike
summary(irisdata$Sepal.Length)
# pravokutni dijagram duljina i sirina latica
boxplot(irisdata[-c(1, 2, 5)])
summary(irisdata[-c(1, 2, 5)])
# dijagram rasprsenja duljine i sirine lapa, s postavljenim oznakama na x i y osima
plot(irisdata$Sepal.Length,irisdata$Sepal.Width,
xlab='Sepal length [cm]',ylab='Sepal width [cm]')
# dijagram rasprsenja duljine i sirine lapa s razlicitim bojama za dvije vrste irisa
plot(irisdata$Sepal.Length[irisdata$Species=='setosa'],
irisdata$Sepal.Width[irisdata$Species=='setosa'],col='blue',
xlim=c(min(irisdata$Sepal.Length),max(irisdata$Sepal.Length)),
ylim=c(min(irisdata$Sepal.Width),max(irisdata$Sepal.Width)),
xlab='Sepal length [cm]',ylab='Sepal width [cm]')
points(irisdata$Sepal.Length[irisdata$Species=='versicolor'],
irisdata$Sepal.Width[irisdata$Species=='versicolor'],col='red')
install.packages("tidyverse")
source("util.r")
players <- read.csv(file="data/players.csv", header=TRUE, sep=",")
seasonsStats <- read.csv(file="data/seasons_stats.csv", header=TRUE, sep=",")
players <- preparePlayerData(players)
seasonsStats <- prepareSeasonsStatsData(seasonsStats, players)
ss <- seasonsStats
pl <- players
years <- 1979:max(ss$Year, na.rm=TRUE)
values <- rep(0, length(years))
for (i in 1:length(years)) {
values[i] <- sum(ss$X3PA[ss$Year == years[i] & !is.na(ss$X3PA)])
}
lm.r <- lm(values ~ years)
plot(years, values, cex=0.5, xlab="Year", ylab="3PA")
abline(lm.r, col="red")
qqline(rstandard(lm.r))
qqnorm(rstandard(lm.r))
qqline(rstandard(lm.r))
qqnorm(rstandard(lm.r))
qqline(rstandard(lm.r))
plot(seasonsStats$X3P., seasonsStats$X3PA, cex=0.1, xlab="3P%", ylab="3PA")
plot(seasonsStats$X3P., seasonsStats$X3PA, cex=0.1, xlab="3P%", ylab="3PA")
plot(seasonsStats$X3P.[seasonsStats$X3PA > 100], seasonsStats$X3PA[seasonsStats$X3PA > 100], cex=0.1, xlab="3P%", ylab="3PA")
plot(seasonsStats$X3P., seasonsStats$X3PA, cex=0.1, xlab="3P%", ylab="3PA")
t
#ss[which(ss$FTA == max(ss$FTA[!is.na(ss$FTA)])), c("Player", "Year", "X3PA", "X3P")]
plot(seasonsStats$FT., seasonsStats$FTA, cex=0.1, xlab="FT%", ylab="FTA")
plot(ss[ss$FTA > 50 & ss$X3PA > 50, c("FT.")], ss[ss$FTA > 50 & ss$X3PA > 50, c("X3P.")], cex=0.1, xlab="FT%", ylab="3P%")
plot(ss[ss$FTA > 50 & ss$X3PA > 50, c("X3P.")], ss[ss$FTA > 50 & ss$X3PA > 50, c("FT.")], cex=0.1, xlab="3P%", ylab="FT%")
plot(seasonsStats$X3P., seasonsStats$X3PA, cex=0.1, xlab="3P%", ylab="3PA")
threePercentages <- ss[ss$FTA > 50 & ss$X3PA > 50, c("X3P.")]
freeThrowPercentages <- ss[ss$FTA > 50 & ss$X3PA > 50, c("FT.")]
lm.r <- lm(threePercentages ~ freeThrowPercentages)
plot(threePercentages, freeThrowPercentages, cex=0.1, xlab="3P%", ylab="FT%")
abline(lm.r, color="red")
plot(threePercentages, freeThrowPercentages, cex=0.1, xlab="3P%", ylab="FT%")
abline(lm.r, col="red")
threePercentages <- ss[ss$FTA > 50 & ss$X3PA > 50, c("X3P.")]
freeThrowPercentages <- ss[ss$FTA > 50 & ss$X3PA > 50, c("FT.")]
lm.r <- lm(threePercentages ~ freeThrowPercentages)
lm.r <- lm(freeThrowPercentages ~ threePercentages)
plot(threePercentages, freeThrowPercentages, cex=0.1, xlab="3P%", ylab="FT%")
abline(lm.r, col="red")
qqnorm(rstandard(lm.r))
qqline(rstandard(lm.r))
ss
ssWithHeight <- data.frame(matrix(ncol=length(names(ss)), nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s$Player
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[pl$name == name]
ssWithHeight <- rbind(ss, c(s, player$height))
}
for (s in ss) {
names(s)
name <- s$Player
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[pl$name == name]
ssWithHeight <- rbind(ss, c(s, player$height))
}
for (s in ss) {
print(names(s))
name <- s$Player
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[pl$name == name]
ssWithHeight <- rbind(ss, c(s, player$height))
}
ss
ss[0]
ss[1]
ss[2]
ss[3]
players
players[3]
players[2]
players[5]
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[pl$name == name]
ssWithHeight <- rbind(ss, c(s, player[5]))
}
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[pl$name == name]
ssWithHeight <- rbind(ss, c(s, player$height))
}
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name]
ssWithHeight <- rbind(ss, c(s, player$height))
}
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ss, c(s, player$height))
}
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ss, c(s, player$height))
}
ssWithHeight
names(ssWithHeight)
names(ssWithHeight)
c(names(ss), "height")
names(ssWithHeight)
names(ssWithHeight)
names(ssWithHeight) <- c(names(ss), "height")
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
names(ssWithHeight)
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ssWithHeight, c(s, player$height))
}
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ssWithHeight, c(s, player$height))
}
ssWithHeight
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
player
break
ssWithHeight <- rbind(ssWithHeight, c(s, player$height))
}
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
print(player)
break
ssWithHeight <- rbind(ssWithHeight, c(s, player$height))
}
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
name <- s[3]
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ssWithHeight, data.frame(c(s, height=player$height)))
}
ssWithHeight
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
names(s) <- names(ss)
name <- s$Player
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ssWithHeight, data.frame(c(s, height=player$height[1])))
}
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
s <- data.frame(setNames(s, names(ss)))
name <- s$Player
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ssWithHeight, data.frame(c(s, height=player$height[1])))
}
ssWithHeight <- data.frame(matrix(ncol=length(names(ss))+1, nrow=0))
names(ssWithHeight) <- c(names(ss), "height")
for (s in ss) {
s <- data.frame(setNames(s, names(ss)))
print(s)
break
name <- s$Player
if (grepl("\\*", name)) {
name <- substr(name, 1, nchar(name)-1)
}
if (name %in% sameNamePlayers$name) {
next
}
player <- pl[as.character(pl$name) == name, ]
ssWithHeight <- rbind(ssWithHeight, data.frame(c(s, height=player$height[1])))
}
